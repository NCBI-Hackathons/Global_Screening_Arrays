#!/usr/bin/python

rule idat_intensity:
    input:
        idat = getIdat
    params:
        color = '{col}'
    output:
        txt = 'idat_intensity_{col}/{idatBase}.intensity.txt',
        R = 'idat_intensity_{col}/{idatBase}.intensity.R',
        Rout = 'idat_intensity_{col}/{idatBase}.intensity.R.out'
    run:
        rTxt = '''
        medianIntensIdat <- function(idat){
        require(illuminaio)
        i <- readIDAT(idat)
        Intens <- i$Quants[,1]
        median(Intens)
        }

        medIntens <- medianIntensIdat("''' + input.idat + '''")
        write.table(medIntens, file = "''' + output.txt + '''", quote = F, row.names = F, col.names = F) 
        '''
        with open(output.R, 'w') as Rout:
            Rout.write(rTxt)
        shell('module load R;R --vanilla < {output.R} > {output.Rout}')

rule fail_intensity:
    input:
        expand('idat_intensity_{col}/{idatBase}.intensity.txt', idatBase = idatBaseDict.keys(), col = ['Red', 'Grn'])
    output:
        'fail_intensity/failed.csv'
    params:
        intensCutoff = float(fail_idat_intensity)
    run:
        with open(output[0], 'w') as out:
            out.write('ChipId,Col,MedianIntensity\n')
            for i in input:
                chipId = os.path.basename(i).split('.')[0]
                col = os.path.dirname(i).split('/')[-1].split('_')[-1]
                with open(i) as f:
                    line = f.readline()
                medIntens = line.strip()
                if float(medIntens) < params.intensCutoff:
                    out.write(','.join([chipId, col, medIntens]) + '\n')

rule combine_idat_intensity:
    input:
        intens = expand('idat_intensity_{{col}}/{idatBase}.intensity.txt', idatBase = idatBaseDict.keys()),
        bad = 'fail_intensity/failed.csv'
    params:
        intensCutoff = float(fail_idat_intensity)
    output:
        'all_sample_idat_intensity/idat_intensity_{col}.csv'
    run:
        badChipDict = {}
        with open(input.bad) as f:
            head = f.readline()
            line = f.readline()
            while line != '':
                samp = line.split(',')[0]
                badChipDict[samp] = 1
                line = f.readline()
        with open(output[0], 'w') as out:
            out.write('ChipId,MedianIntensity\n')
            for i in input.intens:
                chipId = os.path.basename(i).split('.')[0]
                if not badChipDict.get(chipId):
                    with open(i) as f:
                        line = f.readline()
                    medIntens = line.strip()
                    out.write(','.join([chipId, medIntens]) + '\n')


rule make_normalization_groups:
    input:
        'all_sample_idat_intensity/idat_intensity_{col}.csv'
    output:
        groupFiles = expand('{{col}}_normalization_groups/{group}.txt', group = GROUPS),
        R = '{col}_normalization_groups/makeGroups.R',
        Rout = '{col}_normalization_groups/makeGroups.R.out'
    params:
        numOfGroups = str(num_of_groups)
    run:
        rTxt = '''
        data <- read.csv("''' + input[0] + '''")
        newdata <- data[order(data$MedianIntensity),]
        num_of_groups <- ''' + params.numOfGroups + '''
        if (num_of_groups == 1){
        write.table(newdata$ChipId, file = "''' + wildcards.col + '''_normalization_groups/1.txt",
        quote = F, row.names = F, col.names = F)
        } else {
                totSamps <- length(newdata$MedianIntensity)
                samps_per_group <- ceiling(totSamps/num_of_groups)
                groups <- 1:(num_of_groups - 1)
                allIndex <- 1:totSamps
                for (g in groups){
                keepIndex <- sample(allIndex, samps_per_group, replace=FALSE)
                write.table(newdata$ChipId[keepIndex], file = paste("''' + wildcards.col + '''_normalization_groups/", g, ".txt", sep = ""),
                quote = F, row.names = F, col.names = F)
                allIndex <- allIndex[!allIndex %in% keepIndex]
                }
                allSampsAgain <- 1:totSamps
                newIndex <- allSampsAgain[!allSampsAgain %in% allIndex]
                keepIndex <- c(allIndex, sample(newIndex, samps_per_group - length(allIndex), replace=FALSE))
                write.table(newdata$ChipId[keepIndex], file = paste("''' + wildcards.col + '''_normalization_groups/", length(groups) + 1, ".txt", sep = ""), 
                quote = F, row.names = F, col.names = F)
        }
        '''
        with open(output.R, 'w') as Rout:
            Rout.write(rTxt)
        shell('module load R;R --vanilla < {output.R} > {output.Rout}')
        
